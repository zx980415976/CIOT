

### 本章重点内容---“如何对既有代码中的函数进行重构”。


#### 前面对重构的原则及定义做了详细的介绍，所以我们知道，在重构中，最主要的是对函数进行重构，在本篇中提到了函数重构的9大规则。这9大规则在函数代码重构时非常实用，并且也是非常重要的。函数重构的9种类型：

1. Extract Method ---- 提取函数

2. Inline Method ---- 内联函数

3. Replace Temp with Query ---- 以查询取代临时变量

4. Inline Temp ---- 内联临时变量

5. Introduce Explaining Variable ---- 引入解释性变量

6. Split Temporary Variable ---- 分解临时变量

7. Remove Assignments to Parameters ---- 移除对参的赋值

8. Replace Method with Method Object ---- 以函数对象取代函数

9. Substitute Algorithm ---- 替换算法

#### 一. Extract Method(提取函数) ---- 将大函数按模块拆分成几个小的函数

Extract Method被翻译成中文就是提取函数的意思，这一点在代码重构中用的非常非常的多。在重构时提倡将代码模块进行细分，因为模块越小，可重用度就越大。不要写大函数，如果你的函数过大，那么这意味着你的函数需要重构了。因为函数过大，可维护性，可理解性就会变差。并且当你实现类似功能的时候就容易产生重复代码。写代码时，最忌讳的就是代码重复。这也就是经常所说的DRY（Don`t Repeat Yourself）原则。所以当函数过长时，你需要将其细分，将原函数拆分成几个函数。
 
 
例子：下方代码中有两个常量属性，并且该类提供了一个构造器。该类还提供了一个输出方法，就是第一该类中的属性进行打印说明，其实该类中没有什么功能。

Void printOwing= (double amount){

    printBanner();
    
  // print details
  
    System.out.printIn("name:" + _name);
    
    System.out.printIn("amount:" + _amount);
   

  
}


正确做法：下方代码段就是我们重构后的类。经过重构后printOwing()函数就只有两行代码，这样看其中调用的函数名也是很容易理解其作用的。下方拆分出来的三个函数也是一个独立的模块，因为函数短小，所以易于理解，同时也易于重用。

Void printOwing= (double amount){

     printBanner();
     
     printDetails(amount);       
}

Void printDetails= (double amount){

    System.out.printIn("name:" + _name);
    
    System.out.printIn("amount:" + _amount);
     
}

#### 二. Inline Method（内联函数） ---- 将微不足道的小函数进行整合

Inline Method其实是和Extract Method(提取函数)相对的。当你在重构或者平时编程时，对模块进行了过度的封装，也就是使用Extract Method有点过头了，把过于简单的东西进行了封装，比如一个简单的布尔表达式，而且该表达式只被用过一次。此时就是过度的使用Extract Method的表现了。物极必反，所以我们需要使用Inline Method进行中和，将过度封装的函数在放回去，或者将那些没有必要封装的函数放回去。

例子：下方代码中的getRating方法中就返回了一个简单的表达式。

Int getRating(){

      return (moreThanFiveLateDeliveries())? 2 : 1;
}

Boolean moreThanFiveLateDeliveries(){

      return _numberOfLateDeliveries > 5
}

正确做法：将过度封装的函数在放回去，或者将那些没有必要封装的函数放回去。

Int getRating(){

     return (_numberOfLateDeliveries > 5) ? 2 : 1
}


#### 三.Replace Temp with Query（以查询取代临时变量）---- 将一些临时变量使用函数替代

Replace Temp with Query说白了就是将那些有着复杂表达式赋值并且多次使用的临时变量使用查询函数取代，也就是说该临时变量的值是通过函数的返回值来获取的。这样一来在实现类似功能的函数时，这些复杂的临时变量就可以进行复用，从而减少代码的重复率。

例子：在此函数中有一个basePrice临时常量，该常量有一个较为复杂的赋值表达式。

double basePrice = quantity * itemPrice;

if(basePrice > 1000)

     return basePrice * 0.95;
else

     return basePrice * 0.98;

正确做法：新创建一个函数来返回该表达式的值。这个函数中返回的临时变量可以被多次使用。并且上面我们提到的临时常量或者变量都不存在了，取而代之的是查询方法，对应的查询方法返回的就是之前消除的临时变量或常量的值。

if(basePrice() > 1000)
    
     return basePrice() * 0.95;

else

     return basePrice() * 0.98;
// ...

double basePrice(){

     return quantity * itemPrice;
}
     
#### 四、Inline Temp（内联临时变量） ---- 与上面的Replace Temp with Query相反

当临时变量只被一个简单的表达式赋值，而该临时变量妨碍了其他重构手法。此时我们就不应该使用Replace Temp with Query。之所以有时我们会使用到Inline Temp规则，是因为Replace Temp with Query规则使用过度造成的情况，还是物极必反，使用Replace Temp with Query过度时，就需要使用Inline Temp进行修正，当然Inline Temp的示例与Replace Temp with Query正好相反，在此就不做过多的赘述了。

例子：basePrice 这个临时变量，只被简单表达式赋值一次。

double basePrice = anOrder.basePrice();

return basePrice > 1000;

正确做法：将所有对该变量的引用替换为对它赋值的那个表达式自身。

return anOrder.basePrice() > 1000;


#### 五、Introduce Explaining Variable（引入解释性变量）---- 将复杂的表达式拆分成多个变量

当一个函数中有一个比较复杂的表达式时，我们可以将表达式根据功能拆分成不同的变量。拆分后的表达式要比之前未拆分的表达式的可读性更高。将表达式拆分成相应的临时变量，也就是Introduce Explaining Variable，如果临时变量被多次使用的话，我们还可以尝试着使用Replace Temp with Query规则去除临时变量，也就是将临时变量换成查询函数。

例子：在下方这个方法中返回了一个比较长的表达式，第一眼看这个函数感觉会非常的不舒服。因为它返回的表达式太长了，而且可读性不太好。在这种情况下就很有必要将该表达式进行拆分。

if((platform.toUpperCase().indexOf("MAC") > -1) &&(browser.toUpperCase().indexOf("IE") > -1) &&wasInitialized() && resize > 0) {
  
     // do something
}

正确做法：引入解释性变量。顾名思义，我们引入的变量是为了解释该表达式中的一部分的功能的，目的在于让该表达式具有更好的可读性。就相当于为该表达式添加上相应的注释。

final boolean isMacOS = platform.toUpperCase().indexOf("MAC") > -1;

final boolean isIEBrower = browser.toUpperCase().indexOf("IE") > -1;

final boolean wasResized = resize > 0;

if(isMacOS && isIEBrower && wasInitialized() && wasResized) {

     // do something
}
    
 
#### 六、Split Temporary Variable（分解临时变量）---- 一心不可二用

什么叫分解临时变量的，具体说来就是在一个函数中一个临时变量不能做两种事情，也就是一个临时变量不能赋上不同意义的值。

例子：这段代码可以看出temp被重复的赋值了两次的值，如果这两个值关系不大，而且temp不足以对两个值的意思进行说明。

double temp = 2 *(_heirht + _width);

System.out.printIn(temp);

Temp = _heirht * _width;

System.out.printIn(temp);

正确做法：再待分解临时变量的声明及第一次被赋值处，修改名称。将新的临时变量声明为final,在第二次赋值处，重新声明原先那个变量。

final double perimeter= 2 *(_heirht + _width);

System.out.printIn(perimeter);

final double area= _heirht * _width;

System.out.printIn(area);

 
#### 七、Remove Assignments to Parameters（移除对参数的赋值）---- 以一个临时变量取代该参数的位置

“移除对参数的赋值”是什么意思呢？顾名思义，就是在函数中不要对函数参数进行赋值。也就是说你在函数的作用域中不要对函数的参数进行赋值（当然，输入输出参数除外）。因为这样会是参数的原始值丢失，我们需要引入临时变量，然后对这个临时变量进行操作。

例子：下方这个discount()函数就做的不好，因为在discount()函数中直接对非inout参数inputVal进行了修改并且返回了。

int discount (int inputVal, int quentity, int yearToDate){

     if (inputVal > 50) inputVal -= 2;
    
}

正确做法：就是需要将上面的inputVal使用函数的临时变量进行替代即可，下方就是重构后的函数。

int discount (int inputVal, int quentity, int yearToDate){

  int result = inputVal;
    
     if (inputVal > 50) 
     
          result -= 2;
    
}
   
 
#### 八.Replace Method with Method Object（以函数对象取代函数）

当一个特别长的函数，而且函数中含有比较复杂的临时变量，使用上述那些方法不好进行重构时，我们就要考虑将该函数封装成一个类了。这个对应的类的对象就是函数对象。我们可以将该场函数中的参数以及临时变量转变成类的属性，函数要做的事情作为类的方法。(将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段，然后可以在同一个对象中将这个大型函数分解为多个小型函数)

#### 九.Substitute Algorithm（替换算法）
 
复杂的算法会增加维护的成本，替换成较简单的算法实现，往往能明显提高代码的可读性和可维护性。

例子：

String foundPerson(String[] people) {
   
     for (int i = 0; i < people.length; i++) {
     
         if (people[i].equals("Don")) {
         
              return "Don";
         }
         
         if (people[i].equals("Join")) {
         
              return "Join";
         }
         
         if (people[i].equals("Kent")) {
         
              return "Kent";
         }
     }
     
     return "";
}

正确做法：

String foundPerson(String[] people) {
     
List candidates = Array.asList(new String[] {"Don", "Join", "Kent"});
     
     for (int i = 0; i < people.length; i++) {
     
         if (candidates.contains(people[i])) {
         
              return people[i];
         } 
     }
     return "";
}



重新组织函数在代码重构中占有很大的比重。如果用提炼函数将重复的部分提炼出来，每次在需要用到那段逻辑的时候去调用方法这样会使你的代码变得更清爽。当人家阅读你写的代码的时候一眼就能看出。提炼函数的时候最好是以这个函数是“做什么”的来命名，这样别人或者自己阅读很久之前写的代码的时候，只需要看函数名就可以了而不用去了解里面的具体实现提升代码的可阅读性。提炼代码的时候还需注意源函数和被提炼函数里面的变量，被提炼代码中需要读取的局部变量可以当做参数传给目标函数，在原函数中将被提炼的代码换成对目标函数的调用即可。
